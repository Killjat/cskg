# 服务器监控系统设计文档

## 1. 系统概述

### 1.1 设计目标
本设计文档基于《服务器监控系统需求文档》，旨在详细描述服务器监控系统的架构设计、模块划分、核心组件实现方案以及数据流程，确保系统能够满足实时监控服务器活动的需求，包括用户登录、文件操作、进程和命令执行等方面。

### 1.2 设计原则
- **模块化设计**：系统采用模块化架构，各功能模块独立封装，便于扩展和维护
- **高性能**：监控系统自身资源占用低，数据采集延迟小
- **可靠性**：系统稳定运行，故障时不影响被监控服务器
- **安全性**：数据传输和存储安全，访问控制严格
- **可扩展性**：支持分布式部署和功能扩展

### 1.3 系统架构

```
┌─────────────────────────────────────────────────────────────────┐
│                      服务器监控系统                              │
├───────────┬───────────┬───────────┬───────────┬─────────────────┤
│  数据采集层  │  数据处理层  │  数据存储层  │  数据展示层  │    告警模块      │
├───────────┼───────────┼───────────┼───────────┼─────────────────┤
│ 登录监控   │ 数据清洗   │ 关系型数据库 │ Web界面    │ 邮件告警        │
│ 文件监控   │ 数据过滤   │ 时序数据库   │ API接口    │ SMS告警         │
│ 进程监控   │ 数据分析   │ 日志文件     │ 命令行工具  │ 微信告警        │
│ 命令监控   │ 数据关联   │             │             │ 自定义告警        │
└───────────┴───────────┴───────────┴───────────┴─────────────────┘
```

## 2. 核心模块设计

### 2.1 数据采集层

数据采集层负责从服务器获取各类监控数据，包括登录信息、文件操作、进程和命令执行情况。

#### 2.1.1 登录监控模块
- **功能**：采集当前登录账号信息
- **实现方式**：
  - 读取`/var/run/utmp`文件获取当前登录用户
  - 读取`/var/log/wtmp`文件获取历史登录记录
  - 监听SSH登录事件（通过日志或系统调用）
- **数据字段**：用户名、登录时间、来源IP、终端类型、登录时长

#### 2.1.2 文件操作监控模块
- **功能**：监控文件系统操作
- **实现方式**：
  - Linux：使用inotify机制监控文件系统事件
  - 支持监控的操作：创建、读取、写入、删除、移动、重命名
- **数据字段**：操作类型、文件路径、操作时间、执行用户、进程ID

#### 2.1.3 进程监控模块
- **功能**：采集进程信息和命令执行情况
- **实现方式**：
  - 读取`/proc`文件系统获取进程信息
  - 周期性扫描进程列表
  - 监控进程创建和终止事件
- **数据字段**：PID、PPID、进程名称、命令行、启动时间、CPU使用率、内存使用率、状态

#### 2.1.4 命令监控模块
- **功能**：监控当前正在执行的命令
- **实现方式**：
  - 分析`/proc/[PID]/cmdline`和`/proc/[PID]/comm`文件
  - 结合进程监控模块获取命令执行信息
- **数据字段**：命令字符串、PID、执行用户、启动时间、执行时长、CPU使用率、内存使用率

### 2.2 数据处理层

数据处理层负责对采集到的原始数据进行清洗、过滤、分析和关联，生成结构化的监控数据。

#### 2.2.1 数据清洗模块
- **功能**：去除无效数据，格式化数据格式
- **实现方式**：
  - 验证数据完整性
  - 统一数据格式和单位
  - 处理缺失值和异常值

#### 2.2.2 数据过滤模块
- **功能**：根据配置过滤不需要监控的数据
- **实现方式**：
  - 支持白名单和黑名单机制
  - 可配置过滤规则
  - 动态调整过滤策略

#### 2.2.3 数据分析模块
- **功能**：对监控数据进行实时分析
- **实现方式**：
  - 计算统计指标（如进程总数、平均CPU使用率）
  - 检测异常情况（如进程数量异常增长）
  - 识别可疑行为（如异常文件操作）

#### 2.2.4 数据关联模块
- **功能**：关联不同类型的监控数据
- **实现方式**：
  - 关联进程和命令执行数据
  - 关联用户登录和后续操作
  - 建立事件链，便于追溯和审计

### 2.3 数据存储层

数据存储层负责持久化存储处理后的监控数据，支持多种存储方式。

#### 2.3.1 关系型数据库
- **功能**：存储结构化监控数据
- **实现方式**：
  - 支持MySQL、PostgreSQL等数据库
  - 设计合理的数据表结构
  - 实现数据定期备份和清理

#### 2.3.2 时序数据库
- **功能**：存储时序监控数据
- **实现方式**：
  - 支持InfluxDB、Prometheus等时序数据库
  - 优化查询性能
  - 实现数据保留策略

#### 2.3.3 日志文件
- **功能**：以日志形式存储监控数据
- **实现方式**：
  - 支持JSON、CSV等格式
  - 实现日志轮转和压缩
  - 便于与其他日志分析系统集成

### 2.4 数据展示层

数据展示层负责向用户展示监控数据，提供多种访问方式。

#### 2.4.1 Web界面
- **功能**：提供直观的可视化监控界面
- **实现方式**：
  - 基于Gin框架开发Web服务
  - 使用React/Vue构建前端界面
  - 实现实时数据更新和历史数据查询

#### 2.4.2 API接口
- **功能**：提供RESTful API接口，便于与其他系统集成
- **实现方式**：
  - 设计规范的API接口
  - 支持认证和授权
  - 提供API文档

#### 2.4.3 命令行工具
- **功能**：提供命令行工具，便于快速查询监控数据
- **实现方式**：
  - 开发命令行客户端
  - 支持灵活的查询参数
  - 输出格式化数据

### 2.5 告警模块

告警模块负责在检测到异常情况时，通过多种方式向管理员发送告警通知。

#### 2.5.1 告警规则引擎
- **功能**：定义和执行告警规则
- **实现方式**：
  - 支持多种告警规则类型（阈值告警、趋势告警、异常检测）
  - 可配置告警级别和通知方式
  - 实现告警抑制和聚合

#### 2.5.2 告警通知模块
- **功能**：发送告警通知
- **实现方式**：
  - 支持邮件、SMS、微信等多种通知方式
  - 可配置通知模板
  - 实现告警确认和处理流程

## 3. 核心数据模型设计

### 3.1 登录数据模型
```go
type LoginData struct {
    ID           uint      `json:"id" gorm:"primaryKey"`
    Username     string    `json:"username"`
    LoginTime    time.Time `json:"login_time"`
    SourceIP     string    `json:"source_ip"`
    Terminal     string    `json:"terminal"`
    LoginType    string    `json:"login_type"` // local, ssh, etc.
    Duration     int       `json:"duration"`    // in seconds
    LogoutTime   time.Time `json:"logout_time"`
    Status       string    `json:"status"`     // active, logout
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}
```

### 3.2 文件操作数据模型
```go
type FileOperationData struct {
    ID           uint      `json:"id" gorm:"primaryKey"`
    Operation    string    `json:"operation"` // create, read, write, delete, copy, move
    FilePath     string    `json:"file_path"`
    OperationTime time.Time `json:"operation_time"`
    Username     string    `json:"username"`
    PID          int       `json:"pid"`
    ProcessName  string    `json:"process_name"`
    Result       string    `json:"result"` // success, failed
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}
```

### 3.3 进程数据模型
```go
type ProcessData struct {
    ID           uint      `json:"id" gorm:"primaryKey"`
    PID          int       `json:"pid"`
    PPID         int       `json:"ppid"`
    Name         string    `json:"name"`
    Command      string    `json:"command"`
    Username     string    `json:"username"`
    StartTime    time.Time `json:"start_time"`
    CPUUsage     float64   `json:"cpu_usage"`
    MemoryUsage  float64   `json:"memory_usage"`
    Status       string    `json:"status"` // running, sleeping, zombie, etc.
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}
```

### 3.4 命令数据模型
```go
type CommandData struct {
    ID           uint      `json:"id" gorm:"primaryKey"`
    Command      string    `json:"command"`
    PID          int       `json:"pid"`
    PPID         int       `json:"ppid"`
    Username     string    `json:"username"`
    StartTime    time.Time `json:"start_time"`
    Duration     int       `json:"duration"`    // in seconds
    CPUUsage     float64   `json:"cpu_usage"`
    MemoryUsage  float64   `json:"memory_usage"`
    Status       string    `json:"status"`     // running, completed
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}
```

### 3.5 告警数据模型
```go
type AlertData struct {
    ID           uint      `json:"id" gorm:"primaryKey"`
    AlertType    string    `json:"alert_type"` // login, file, process, command
    AlertLevel   string    `json:"alert_level"` // info, warning, error, critical
    Message      string    `json:"message"`
    Detail       string    `json:"detail"`
    Status       string    `json:"status"`     // pending, acknowledged, resolved
    AcknowledgedBy string  `json:"acknowledged_by"`
    AcknowledgedTime time.Time `json:"acknowledged_time"`
    ResolvedTime  time.Time `json:"resolved_time"`
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}
```

## 4. 核心组件实现方案

### 4.1 登录监控组件

#### 4.1.1 实现思路
- 读取`/var/run/utmp`文件获取当前登录用户
- 读取`/var/log/wtmp`文件获取历史登录记录
- 使用`last`命令解析登录记录
- 定期扫描登录信息，检测变化

#### 4.1.2 关键代码结构
```go
package collector

import (
    "time"
    "github.com/example/server-monitor/internal/model"
)

type LoginCollector interface {
    CollectCurrentLogins() ([]model.LoginData, error)
    CollectLoginHistory() ([]model.LoginData, error)
    Start() error
    Stop() error
}

type loginCollector struct {
    ticker *time.Ticker
    done   chan bool
}

func NewLoginCollector() LoginCollector {
    return &loginCollector{
        ticker: time.NewTicker(5 * time.Second),
        done:   make(chan bool),
    }
}

func (lc *loginCollector) CollectCurrentLogins() ([]model.LoginData, error) {
    // 实现读取当前登录用户的逻辑
    return nil, nil
}

func (lc *loginCollector) CollectLoginHistory() ([]model.LoginData, error) {
    // 实现读取登录历史的逻辑
    return nil, nil
}

func (lc *loginCollector) Start() error {
    // 启动定期采集
    go func() {
        for {
            select {
            case <-lc.ticker.C:
                // 采集登录数据
            case <-lc.done:
                return
            }
        }
    }()
    return nil
}

func (lc *loginCollector) Stop() error {
    // 停止采集
    lc.done <- true
    lc.ticker.Stop()
    return nil
}
```

### 4.2 文件操作监控组件

#### 4.2.1 实现思路
- 在Linux系统上使用inotify机制监控文件系统事件
- 支持递归监控目录
- 过滤不需要监控的文件和目录
- 关联文件操作到具体用户和进程

#### 4.2.2 关键代码结构
```go
package collector

import (
    "time"
    "github.com/fsnotify/fsnotify"
    "github.com/example/server-monitor/internal/model"
)

type FileCollector interface {
    CollectFileOperations() ([]model.FileOperationData, error)
    AddWatch(path string, recursive bool) error
    RemoveWatch(path string) error
    Start() error
    Stop() error
}

type fileCollector struct {
    watcher *fsnotify.Watcher
    done    chan bool
    watches map[string]bool
}

func NewFileCollector() (FileCollector, error) {
    watcher, err := fsnotify.NewWatcher()
    if err != nil {
        return nil, err
    }
    return &fileCollector{
        watcher: watcher,
        done:    make(chan bool),
        watches: make(map[string]bool),
    }, nil
}

func (fc *fileCollector) CollectFileOperations() ([]model.FileOperationData, error) {
    // 实现文件操作采集逻辑
    return nil, nil
}

func (fc *fileCollector) AddWatch(path string, recursive bool) error {
    // 实现添加监控路径的逻辑
    return nil
}

func (fc *fileCollector) RemoveWatch(path string) error {
    // 实现移除监控路径的逻辑
    return nil
}

func (fc *fileCollector) Start() error {
    // 启动文件监控
    go func() {
        for {
            select {
            case event, ok := <-fc.watcher.Events:
                if !ok {
                    return
                }
                // 处理文件系统事件
            case err, ok := <-fc.watcher.Errors:
                if !ok {
                    return
                }
                // 处理错误
            case <-fc.done:
                return
            }
        }
    }()
    return nil
}

func (fc *fileCollector) Stop() error {
    // 停止文件监控
    fc.done <- true
    return fc.watcher.Close()
}
```

### 4.3 进程监控组件

#### 4.3.1 实现思路
- 读取`/proc`文件系统获取进程信息
- 定期扫描进程列表
- 计算进程的CPU和内存使用率
- 关联进程到具体用户

#### 4.3.2 关键代码结构
```go
package collector

import (
    "time"
    "github.com/example/server-monitor/internal/model"
)

type ProcessCollector interface {
    CollectProcesses() ([]model.ProcessData, error)
    GetProcessByPID(pid int) (model.ProcessData, error)
    GetProcessCount() (int, error)
    Start() error
    Stop() error
}

type processCollector struct {
    ticker *time.Ticker
    done   chan bool
}

func NewProcessCollector() ProcessCollector {
    return &processCollector{
        ticker: time.NewTicker(2 * time.Second),
        done:   make(chan bool),
    }
}

func (pc *processCollector) CollectProcesses() ([]model.ProcessData, error) {
    // 实现采集进程列表的逻辑
    return nil, nil
}

func (pc *processCollector) GetProcessByPID(pid int) (model.ProcessData, error) {
    // 实现根据PID获取进程信息的逻辑
    return model.ProcessData{}, nil
}

func (pc *processCollector) GetProcessCount() (int, error) {
    // 实现获取进程总数的逻辑
    return 0, nil
}

func (pc *processCollector) Start() error {
    // 启动进程监控
    go func() {
        for {
            select {
            case <-pc.ticker.C:
                // 采集进程数据
            case <-pc.done:
                return
            }
        }
    }()
    return nil
}

func (pc *processCollector) Stop() error {
    // 停止进程监控
    pc.done <- true
    pc.ticker.Stop()
    return nil
}
```

### 4.4 命令监控组件

#### 4.4.1 实现思路
- 基于进程监控组件，提取命令执行信息
- 分析`/proc/[PID]/cmdline`和`/proc/[PID]/comm`文件
- 监控命令的启动和终止
- 计算命令执行时长和资源使用情况

#### 4.4.2 关键代码结构
```go
package collector

import (
    "time"
    "github.com/example/server-monitor/internal/model"
)

type CommandCollector interface {
    CollectCurrentCommands() ([]model.CommandData, error)
    CollectCommandHistory() ([]model.CommandData, error)
    Start() error
    Stop() error
}

type commandCollector struct {
    ticker *time.Ticker
    done   chan bool
}

func NewCommandCollector() CommandCollector {
    return &commandCollector{
        ticker: time.NewTicker(2 * time.Second),
        done:   make(chan bool),
    }
}

func (cc *commandCollector) CollectCurrentCommands() ([]model.CommandData, error) {
    // 实现采集当前执行命令的逻辑
    return nil, nil
}

func (cc *commandCollector) CollectCommandHistory() ([]model.CommandData, error) {
    // 实现采集命令历史的逻辑
    return nil, nil
}

func (cc *commandCollector) Start() error {
    // 启动命令监控
    go func() {
        for {
            select {
            case <-cc.ticker.C:
                // 采集命令数据
            case <-cc.done:
                return
            }
        }
    }()
    return nil
}

func (cc *commandCollector) Stop() error {
    // 停止命令监控
    cc.done <- true
    cc.ticker.Stop()
    return nil
}
```

## 5. 数据流程设计

### 5.1 数据采集流程

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   数据采集模块     │────▶│   数据处理模块     │────▶│   数据存储模块     │
└─────────────────┘     └─────────────────┘     └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   定时任务触发     │     │   数据清洗过滤     │     │   多存储方式支持   │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

### 5.2 告警处理流程

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   数据处理模块     │────▶│   告警规则引擎     │────▶│   告警通知模块     │
└─────────────────┘     └─────────────────┘     └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   异常检测       │     │   规则匹配       │     │   多渠道通知     │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

### 5.3 数据查询流程

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   用户请求       │────▶│   API/Web界面    │────▶│   数据存储模块     │
└─────────────────┘     └─────────────────┘     └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   多样化查询     │     │   数据聚合分析     │     │   高效数据检索     │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

## 6. 系统部署方案

### 6.1 部署架构

#### 6.1.1 单机部署
- 适合监控单台服务器
- 监控系统与被监控服务器部署在同一台机器上
- 资源占用低，部署简单

#### 6.1.2 分布式部署
- 适合监控多台服务器
- 采用主从架构：
  - 主节点：负责数据存储、展示和告警
  - 从节点：部署在被监控服务器上，负责数据采集
- 主从节点通过网络通信，传输监控数据

### 6.2 部署步骤

1. **环境准备**：
   - 安装Go 1.21+
   - 安装依赖库
   - 配置数据库（可选）

2. **编译安装**：
   - 编译监控系统二进制文件
   - 配置系统服务
   - 启动监控服务

3. **配置优化**：
   - 调整采集频率
   - 配置监控路径
   - 设置告警规则
   - 配置数据保留策略

## 7. 系统扩展方案

### 7.1 功能扩展
- 支持新增监控类型：
  - 网络流量监控
  - 磁盘IO监控
  - 系统负载监控
  - 服务状态监控

- 支持新增告警方式：
  - Slack告警
  - Telegram告警
  - 企业微信告警

### 7.2 性能扩展
- 采用分布式架构，支持监控更多服务器
- 优化数据采集和处理算法
- 采用更高效的存储方案
- 实现数据采样和压缩

### 7.3 集成扩展
- 支持与其他系统集成：
  - 与Prometheus、Grafana集成，实现更丰富的可视化
  - 与ELK Stack集成，实现更强大的日志分析
  - 与自动化运维工具集成，实现告警自动处理

## 8. 测试方案

### 8.1 功能测试
- 测试登录监控功能
- 测试文件操作监控功能
- 测试进程监控功能
- 测试命令监控功能
- 测试告警功能

### 8.2 性能测试
- 测试监控系统自身资源占用
- 测试数据采集延迟
- 测试系统在高负载下的表现

### 8.3 可靠性测试
- 测试系统稳定性
- 测试故障恢复能力
- 测试数据完整性

### 8.4 安全性测试
- 测试数据传输安全性
- 测试访问控制有效性
- 测试日志保护机制

## 9. 维护方案

### 9.1 日常维护
- 定期检查系统运行状态
- 定期备份监控数据
- 定期清理过期数据
- 监控系统自身资源占用

### 9.2 故障处理
- 建立故障处理流程
- 定期演练故障恢复
- 记录和分析故障原因

### 9.3 版本更新
- 制定版本更新计划
- 测试新版本功能和性能
- 平滑升级系统版本

## 10. 结论

本设计文档详细描述了服务器监控系统的架构设计、模块划分、核心组件实现方案以及数据流程，确保系统能够满足实时监控服务器活动的需求。系统采用模块化设计，具有高性能、高可靠性、高安全性和良好的可扩展性，能够适应不同规模的服务器监控需求。

通过本设计方案，我们可以实现一个功能完整、性能优良的服务器监控系统，为服务器管理和安全审计提供有力支持。